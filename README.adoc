# OGD kerstpuzzel 2018

image::https://imgs.xkcd.com/comics/puzzle.png[link="https://imgs.xkcd.com/comics/puzzle.png"]

*Hoi BUSBietjes...*

Het is weer het einde van het jaar. Tijd voor de meeste van jullie om een à
twee weken verlof op te nemen. Maar twee weken zonder je werk is wel heel erg
afkicken natuurlijk. Daarom heb ik speciaal – om je niet te hoeven vervelen –
een heuse kerstpuzzel geschreven. Een beetje als de AIVD-kerstpuzzel. Maar dan
leuker!

Want deze puzzel kun je oplossen door te programmeren. En… je kunt ook een
echte prijs winnen. Hoe doe je dat? Stuur je oplossing in *voor 15 januari 2019*
bij mij. De beste inzending wint sowieso een waardebon van €25. Maar als jouw
algoritme beter presteert dan mijn implementatie dan verdubbel ik de prijs.
Kijk! Nu heb ik je aandacht ;-). Makkelijk scoren tegen zo’n Product Owner zou
ik zeggen… dus doe mee!

*De opdracht*

Ok, wat moet je doen? Schrijf een algoritme voor het BCPP. Het watte? Het BCPP
probleem. Dat staat voor “BUSBI’s Camper Parking Problem” en is een serieus
combinatorisch probleem waar we binnen de BUS mee in onze maag zitten. Zoals
je weet hebben we binnen de BUS grootse plannen. Daarom willen we het aantal
OGD campers fors uitbreiden. Om de kosten voor de benodigde stalling binnen de
perken te houden willen we zoveel mogelijk campers op een zo klein mogelijke
oppervlak kunnen stallen.

Probleempje... het formaat van de camper ligt nog niet vast. En ook de grootte
van de stalling nog niet. Dus we hebben een abstract algoritme nodig die
een optimale plaatsing kan berekenen in termen van `(W, D, l, b)`. De
oppervlakte van de stalling is `W * D` met `W > D`. De camper heeft het
formaat van `l` bij `b`, met `l > b`.

Tijd voor een voorbeeld. In de plaatjes hieronder zie je een aantal
uitwerkingen van de instantie `(W,D,l,b)=(42,39,9,4)`:

a. Campers moeten binnen het terrein van de stalling vallen en campers op
   elkaar stapelen doen we toch maar niet, dus deze uitwerking is niet valide.
   Je zou er 0 punten voor krijgen.
+

image::content/example1.png[]
b. Met een naief algoritme kom je al heel ver... 42 geplaatste campers. Je
   houdt nog ruimte over, maar beter dan 0 punten door een time-out ;-).
   Toch 42 punten in de pocket!
+

image::content/example2.png[]
c. Maar de echte uitdaging is natuurlijk om het optimum te vinden. Hier zie
   je een mogelijke uitwerking van het maximum aantal te plaatsen campers van 45.
   En dat levert je dus het maximum aantal punten van 45 op voor deze case.

image::content/example3.png[]

*Praktische zaken*

Schrijf een commandline programma in je favoriete taal. Zorg dat duidelijk is
hoe we je programma moeten bouwen indien nodig. Ik run de inzendingen op een
native draaiende fedora 29, waarbij elke inzending gethrottled wordt
naar 1 core (pentium i5), 8 GB geheugen en 30 sec cpu tijd.

Om duidelijk te maken wat we als input en output verwachten stel ik een
kick-start Python3 script beschikbaar in de repo. Kun je gelijk lekker snel
aan de slag. Andere talen gaan analoog. In ieder geval moet het programma de
volgende invoer accepteren:
```
> kerstpuzzel2018.py <W> <D> <l> <b>
```
De uitvoer is een JSON-array met voor elke geplaatste camper een array met de
integer x,y-coordinaten van de linker-onderhoek en een letter H,V voor de
orientatie. Bijvoorbeeld, de (beetje ingekorte) uitvoer van (b) in het
voorbeeld zou zijn:
```
> kerstpuzzel.py 42 39 9 4
[[0,0,"V"],[4,0,"V"], ... ,[27,35,"H"]]
```
En van (c):
```
> kerstpuzzel.py 42 39 9 4
[[0,0,"H"],[9,0,"H"], ... ,[33,35,"H"]]
```

*Beoordelingscriteria*

Ik ga je script 1000 keer aanroepen met iedere keer een andere case, van
makkelijk tot moeilijk. Puntentelling:

- Voor een oplossing die niet valide is (overlap etc.) en bij een timeout
  na 30 sec. krijg je geen punten.
- Verder is iedere geplaatste camper 1 punt.

De winnaar is degene met de meeste punten opgeteld over alle cases. Gelijk
aantal punten? Dan wint degene met mooiste implementatie.

*Tips*

Je mag alle algoritmische technieken gebruiken die je maar wilt. Brute-force,
Branch-and-bound, Alpha-Beta-Pruning, tabu-search, divide-and-conquer,
hill-climbing, dynamic-programming, greedy, integer linear programming,
stochastic beam search, you name it.

Een genetisch algoritme (GA) mag ook natuurlijk, maar gaat je waarschijnlijk
niet de eerste plek opleveren. Een GA heeft vooral voordelen wanneer binnen de
genen 'zones' vormen die elk een afgebakende oppervlakte op de stallingplek
representeren. (Dit heet in de GA-literatuur trouwens 'schemata'). Maar in dat
geval zijn er constructieve alternatieven die veel sneller naar een resultaat
convergeren.

Oh ja… 0 punten scoren op een case zou echt niet nodig hoeven zijn! Met een
beetje time management en netjes programmeren hoef je niet in de valkuil van
het eerste criterium te vallen.

*Twijfel niet langer!*

Wil je meedoen? Stuur dan een mailtje naar marcel.tode@ogd.nl. Dan krijg je
een mapje + branch in mijn gitrepo en kun je aan de slag.

Werk je niet bij de BUS en denk je van... ‘wow wat doen ze vette dingen bij de
BUSBI’. Dat klopt! Maar niet getreurd, ook jij mag meedoen. Win en breng jezelf
in ons vizier!

Na de deadline breng ik alle resultaten, software en tooling online, zodat
iedereen zelf alles kan checken. Ik hoop op veel aanmeldingen. Veel plezier!
En veel succes!

Fijne feestdagen en een gelukkig nieuwjaar alvast!
